%%%% EEG Preprocessing Pipeline
%%%% Adapted for MI and Rest conditions
%%%% Markers: 'S  3' (MI) and 'S  4' (Rest)
%%%% Epoch: [-3 4] seconds

% clear all;
% close all;
clc;

%% Set paths
path_to_rawdata = './data/CBH/';
path_to_epoched = './epoched/';

% Create output directory if it doesn't exist
if ~exist(path_to_epoched, 'dir')
    mkdir(path_to_epoched);
end

%% Define parameters
nSubject = 25;  % Number of subjects
subjectNum = 0;
filename = "";
coinType = "gold";  % Filter for specific coin events
toggle_skip = true; % Filter out self-reported unsuccessful MI/Rest trials

% For 1 subject
if nSubject == 1 && (subjectNum < 10)
    filename = ['CBH000' int2str(subjectNum)];  % or choose a specific file
end

if nSubject == 1 && mod(subjectNum,2) == 1
    markerStartLetter = 'S';
else
    markerStartLetter = 'R';
end

events = {
          [markerStartLetter '  3'], 'MI';    % Motor Imagery
          [markerStartLetter '  4'], 'Rest';  % Rest condition
          [markerStartLetter '  9'], 'TapStart';   % Tapzone start
          % [markerStartLetter ' 10'], 'Tapped'   % Tapped during tap zone
          % [markerStartLetter ' 11'], 'TapEnd'   % Tapzone end
          };


% Epoch parameters
epoch_period = [-3 4];          % -3 to 4 seconds
baseline_period = [-2000 -1000];     % baseline

% Load channel locations
load ./reference/NewEasyCap63.mat  % Assuming this file exists

%% Initialize summary storage
% Create a cell array to store the counts of skipped trials for each subject.
skipped_counts_summary = cell(nSubject + 1, 5);
skipped_counts_summary(1,:) = {'SubjectID', 'Skipped_MI_Pre', 'Skipped_MI_Post', 'Skipped_Rest_Pre', 'Skipped_Rest_Post'};


%% Main preprocessing loop
for sub = 1:nSubject
    
    % Initialize counters for the current subject
    skipped_mi_count_pre = 0;
    skipped_mi_count_post = 0;
    skipped_rest_count_pre = 0;
    skipped_rest_count_post = 0;

    fprintf('Processing Subject %d/%d\n', sub, nSubject);
    
    % Load raw data
    if (sub < 10)
        filename = ['CBH000' int2str(sub)];  % or choose a specific file
    else
        filename = ['CBH00' int2str(sub)];  % or choose a specific file
    end
    set_file = [path_to_rawdata '' filename '.vhdr'];
    
    % Set condition markers
    if mod(sub,2) == 1
        markerStartLetter = 'S';
    else
        markerStartLetter = 'R';
    end
    
    events = {
              [markerStartLetter '  3'], 'MI';    % Motor Imagery
              [markerStartLetter '  4'], 'Rest';  % Rest condition
              [markerStartLetter '  9'], 'TapStart';   % Tapzone start
              % [markerStartLetter ' 10'], 'Tapped'   % Tapped during tap zone
              [markerStartLetter ' 11'], 'TapEnd'   % Tapzone end
              };

    disp(set_file)

    if ~exist(set_file, 'file')
        fprintf('Warning: File not found for subject %d\n', sub);
        continue;
    end
    
    fprintf('Reading %s...\n', set_file);
    
    % Load EEG data
    EEG = pop_fileio(set_file);
    
    % Set channel locations
    EEG.chanlocs = struct(chanlocsEasyCapNoRef);
    EEG = eeg_checkset(EEG);
    
    % Add reference channel FCz as channel 64
    EEG = pop_chanedit(EEG, 'append', 63, ...
        'changefield', {64 'labels' 'FCz'}, ...
        'changefield', {64 'X' '0.383'}, ...
        'changefield', {64 'Y' '0'}, ...
        'changefield', {64 'Z' '0.923'}, ...
        'convert', {'cart2all'});
    EEG = eeg_checkset(EEG);
    
    %% Channel removal
    % Remove bad channels (FT9, FT10, TP9, TP10)
    ex_channels = [5 10 21 27];
    EEG = pop_select(EEG, 'nochannel', ex_channels);
    nCh = EEG.nbchan;
    
    %% Filtering
    fprintf('Applying filters...\n');
    
    % Bandpass filter [0.1-85Hz]
    EEG = pop_eegfiltnew(EEG, 0.1, 85, 33000, 0, [], 1);
    EEG = eeg_checkset(EEG);
    
    % Notch filter at 50Hz
    EEG = pop_eegfiltnew(EEG, 49.5, 50.5, 8250, 1, [], 1);
    EEG = eeg_checkset(EEG);
    close all;
    
    %% Artifact Subspace Reconstruction (ASR)
    fprintf('Running ASR...\n');
    
    % Store channel info before ASR
    infoCh = {EEG.chanlocs.labels};
    saveEEG = struct(EEG);
    
    % Apply ASR
    EEG = clean_rawdata(EEG, 10, [0.25 0.75], 0.8, 4, 20, 0.5);
    
    nChMiss = EEG.nbchan;
    [M, N] = size(EEG.data);
    
    %% Find and interpolate missing channels
    % Expand data matrix to original size
    EEG.data = [EEG.data(:,:); zeros(nCh-nChMiss, N)];
    
    missCh = {};
    missChNum = [];
    
    for i = 1:nCh
        temp = max(strcmp(infoCh(i), {EEG.chanlocs.labels}));
        if temp == 0
            missCh = [missCh infoCh(i)];
            missChNum = [missChNum i];
            EEG.data(i+1:end,:) = EEG.data(i:end-1,:);
            EEG.data(i,:) = zeros(1, N);
        end
    end
    
    % Restore original channel structure
    EEG.nbchan = saveEEG.nbchan;
    EEG.chanlocs = struct(saveEEG.chanlocs);
    EEG = eeg_checkset(EEG);
    
    % Interpolate missing channels
    if ~isempty(missChNum)
        fprintf('Interpolating %d channels...\n', length(missChNum));
        EEG = pop_interp(EEG, missChNum, 'spherical');
        EEG = eeg_checkset(EEG);
    end
    
    %% Common Average Reference (CAR)
    fprintf('Applying CAR...\n');
    
    % Re-reference to average with FCz retained
    EEG = pop_reref(EEG, [], 'refloc', struct(...
        'theta', {0}, ...
        'radius', {0.1252}, ...
        'labels', {'FCz'}, ...
        'sph_theta', {0}, ...
        'sph_phi', {67.4639}, ...
        'X', {0.383}, ...
        'Y', {0}, ...
        'Z', {0.923}, ...
        'sph_radius', {0.99931}, ...
        'type', {''}, ...
        'ref', {''}, ...
        'urchan', {[]}, ...
        'datachan', {0}));
    EEG = eeg_checkset(EEG);
    
    %% Find boundary marker before cleaning events
    % This is needed to correctly assign skipped trials to pre/post bins.
    tap_start_marker = [markerStartLetter '  9'];
    all_event_types_for_boundary = {EEG.event.type};
    boundary_event_index = find(strcmp(all_event_types_for_boundary, tap_start_marker), 1, 'first');

    if isempty(boundary_event_index)
        fprintf('Warning: No TapStart marker ("%s") found for subject %s. Cannot separate pre/post NO counts.\n', tap_start_marker, filename);
    end

    %% Clean events and count "NO" evaluations
    % Remove empty markers, fix broken ones
    del = 0;
    for j = 1:size(EEG.event, 2)
        if strcmp(EEG.event(j-del).type, 'empty')
            EEG.event(j-del) = [];
            del = del + 1;
        end
    end
    
    countMI = 0;
    countRest = 0;
    
    for j = 1:size(EEG.event, 2)
        % issue in initial Unity code sent S3 instead of S7 for gold coins
        if strcmp(EEG.event(j).type, [markerStartLetter '  3'])
            countMI = countMI + 1;
            sprintf( 'Prev marker: %s', EEG.event(j + 1).type );
            if(strcmp(EEG.event(j - 1).type, [markerStartLetter '  2']) == 0)
                sprintf( 'Prev marker: %s', EEG.event(j + 1).type );
                EEG.event(j).type = [markerStartLetter '  7'];
            end
        elseif strcmp(EEG.event(j).type, [markerStartLetter '  4'])
            countRest = countRest + 1;
        end
        % if tapzone enter, check cointype
        if (coinType ~= "") && (strcmp(EEG.event(j).type, [markerStartLetter '  9']))
            if(coinType == "gold")
                coinMarker = [markerStartLetter '  7'];
            elseif (coinType == "wooden")
                coinMarker = [markerStartLetter '  8'];
            end

            if(strcmp(EEG.event(j - 1).type, coinMarker))
                EEG.event(j).type = 'skip';
            end
        end

        % If EVAL NO, then toggle skip for Rest/MI marker before
        if (strcmp(EEG.event(j).type, [markerStartLetter '  15']))
            if(toggle_skip)
                % Check if the event 2 positions before is MI or Rest
                if (j > 2) % Ensure we don't go out of bounds
                    is_pre_trial = ~isempty(boundary_event_index) && (j - 2 < boundary_event_index);

                    if (strcmp(EEG.event(j - 2).type, [markerStartLetter '  3'])) % It's an MI trial
                        if is_pre_trial
                            skipped_mi_count_pre = skipped_mi_count_pre + 1;
                        else % It's a post trial (or no boundary found, treat as post/all)
                            skipped_mi_count_post = skipped_mi_count_post + 1;
                        end
                        EEG.event(j-2).type = 'skip'; % Mark for removal
                    elseif (strcmp(EEG.event(j - 2).type, [markerStartLetter '  4'])) % It's a Rest trial
                        if is_pre_trial
                            skipped_rest_count_pre = skipped_rest_count_pre + 1;
                        else % It's a post trial
                            skipped_rest_count_post = skipped_rest_count_post + 1;
                        end
                        EEG.event(j-2).type = 'skip'; % Mark for removal
                    end
                end
            end
        end
    end
    
    % Store the final counts for the current subject in the summary array
    skipped_counts_summary{sub + 1, 1} = filename;
    skipped_counts_summary{sub + 1, 2} = skipped_mi_count_pre;
    skipped_counts_summary{sub + 1, 3} = skipped_mi_count_post;
    skipped_counts_summary{sub + 1, 4} = skipped_rest_count_pre;
    skipped_counts_summary{sub + 1, 5} = skipped_rest_count_post;
    
    fprintf('Subject %s -> Skipped MI (Pre/Post): %d/%d, Skipped Rest (Pre/Post): %d/%d\n', ...
        filename, skipped_mi_count_pre, skipped_mi_count_post, skipped_rest_count_pre, skipped_rest_count_post);


    %% Epoching for MI and Rest conditions based on TapStart marker
    fprintf('Epoching data...\n');

    % Get all event types *after* cleaning and marking skips
    all_event_types = {EEG.event.type};

    for evt = 1:size(events, 1)
        % Extract epochs for the current condition (e.g., MI or Rest)
        fprintf('Processing %s condition...\n', events{evt, 2});
        
        % Find all valid (not 'skip') events for the current condition
        event_marker = events{evt, 1};
        events_only_indices = find(strcmp(all_event_types, event_marker));

        % Loop to create three sets of epochs: pre-TapStart, post-TapStart, and all
        for s = 1:3
            selected = [];
            epoch_label = '';

            if s == 1 % Pre-TapStart trials
                epoch_label = 'pre';
                fprintf('Processing %s %s...\n', events{evt, 2}, epoch_label);
                if ~isempty(boundary_event_index)
                    if()
                    selected = events_only_indices(events_only_indices < boundary_event_index);
                end

            elseif s == 2 % Post-TapStart trials
                epoch_label = 'post';
                fprintf('Processing %s %s...\n', events{evt, 2}, epoch_label);
                 if ~isempty(boundary_event_index)
                    selected = events_only_indices(events_only_indices > boundary_event_index);
                 end

            else % All trials
                epoch_label = 'all';
                fprintf('Processing %s %s...\n', events{evt, 2}, epoch_label);
                selected = events_only_indices;
            end
            
            epoch_file = sprintf('%s_%s_%s.set', filename, events{evt, 2}, epoch_label);

            if isempty(selected)
                fprintf('  - No events found for this condition/%s. Skipping.\n', epoch_label);
                continue;
            end
            
            fprintf('  - Found %d events for %s.\n', length(selected), epoch_label);

            % Temporarily modify event types for selected events to create unique identifiers.
            % This ensures pop_epoch only grabs the trials for the current selection (pre, post, or all).
            temp_event_type = sprintf('TEMP_%s_%s', events{evt, 2}, epoch_label);
            
            % Store original types and set temporary types for selected events
            for i = 1:length(selected)
                EEG.event(selected(i)).type = temp_event_type;
            end
            
            % Epoch around the temporarily renamed events
            epoch = pop_epoch(EEG, {temp_event_type}, epoch_period, 'epochinfo', 'yes');
            
            % Restore original event types in the main EEG structure to not affect subsequent loops
            for i = 1:length(selected)
                % Find the original event by its index and restore its type
                original_event_index_in_EEG = selected(i);
                EEG.event(original_event_index_in_EEG).type = event_marker;
            end
            
            % Apply baseline correction
            % epoch = pop_rmbase(epoch, baseline_period);
            epoch = eeg_checkset(epoch);
            
            % Display epoch info
            fprintf('  - Number of epochs: %d\n', epoch.trials);
            fprintf('  - Epoch length: %.1f seconds\n', epoch.xmax - epoch.xmin);
            
            % Save epoched data
            epoch = pop_saveset(epoch, ...
                'filename', epoch_file, ...
                'filepath', path_to_epoched, ...
                'savemode', 'onefile');
            
            fprintf('  - Saved: %s\n', fullfile(path_to_epoched, epoch_file));
       end
    end
    
    fprintf('Subject %d completed!\n\n', sub);
end

fprintf('Preprocessing completed for all subjects!\n\n');

% Display the summary of skipped counts in the command window
disp('Summary of Self-Reported "NO" Evaluations:');
disp(skipped_counts_summary);

% Optionally, save the results to a file for later analysis
% save('skipped_counts_summary.mat', 'skipped_counts_summary');
% writecell(skipped_counts_summary, 'skipped_counts_summary.csv');
fprintf('Skipped counts summary has been generated.\n');
